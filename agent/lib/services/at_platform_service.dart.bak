import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:at_client/at_client.dart';
import 'package:at_onboarding_cli/at_onboarding_cli.dart';
import 'package:logging/logging.dart';
import '../models/message.dart';

/// Service for managing atPlatform connections and encrypted storage
class AtPlatformService {
  final Logger _logger = Logger('AtPlatformService');
  final String atSign;
  final String keysFilePath;
  final String rootServer;
  final String? instanceId;

  AtClient? _atClient;
  bool _isInitialized = false;

  AtPlatformService({
    required this.atSign,
    required this.keysFilePath,
    this.rootServer = 'root.atsign.org',
    this.instanceId,
  });

  /// Initialize the atPlatform connection
  Future<void> initialize() async {
    if (_isInitialized) {
      _logger.info('AtPlatform already initialized');
      return;
    }

    try {
      _logger.info('Initializing atPlatform for $atSign');

      // Load the atKeys file
      final keysFile = File(keysFilePath);
      if (!await keysFile.exists()) {
        throw Exception('atKeys file not found at $keysFilePath');
      }

      // Create unique storage paths for each agent instance
      // This prevents file locking conflicts when running multiple agents with same atSign
      final storageSuffix = instanceId != null && instanceId!.isNotEmpty
          ? '_${instanceId!.replaceAll(RegExp(r'[^a-zA-Z0-9]'), '_')}'
          : '';
      final hiveStoragePath = './storage/hive$storageSuffix';
      final commitLogPath = './storage/commit$storageSuffix';

      _logger.info('Storage paths:');
      _logger.info('  Hive: $hiveStoragePath');
      _logger.info('  Commit: $commitLogPath');

      // Setup onboarding preferences (similar to at_notifications demo)
      final preference = AtOnboardingPreference()
        ..rootDomain = rootServer
        ..namespace = 'personalagent'
        ..hiveStoragePath = hiveStoragePath
        ..commitLogPath = commitLogPath
        ..isLocalStoreRequired = true
        ..atKeysFilePath = keysFilePath;

      // Use AtOnboardingService for proper PKAM authentication
      _logger.info('Authenticating with PKAM...');
      final onboardingService = AtOnboardingServiceImpl(atSign, preference);

      final authenticated = await onboardingService.authenticate();
      if (!authenticated) {
        throw Exception('Failed to authenticate $atSign with PKAM');
      }

      _logger.info('‚úÖ PKAM authentication successful');

      // Get the authenticated atClient
      _atClient = onboardingService.atClient;
      _isInitialized = true;

      _logger.info('‚úÖ AtPlatform initialized successfully');
    } catch (e, stackTrace) {
      _logger.severe('Failed to initialize atPlatform', e, stackTrace);
      rethrow;
    }
  }

  /// Store encrypted context data
  Future<void> storeContext(ContextData context) async {
    _ensureInitialized();

    try {
      final atKey = AtKey()
        ..key = 'context.${context.key}'
        ..namespace = 'personalagent'
        ..sharedWith = atSign; // Only accessible by this atSign

      final jsonData = json.encode(context.toJson());
      await _atClient!.put(atKey, jsonData);

      _logger.info('Stored context: ${context.key}');
    } catch (e, stackTrace) {
      _logger.severe('Failed to store context', e, stackTrace);
      rethrow;
    }
  }

  /// Retrieve encrypted context data
  Future<ContextData?> getContext(String key) async {
    _ensureInitialized();

    try {
      final atKey = AtKey()
        ..key = 'context.$key'
        ..namespace = 'personalagent'
        ..sharedWith = atSign;

      final value = await _atClient!.get(atKey);
      if (value.value == null) {
        return null;
      }

      final jsonData = json.decode(value.value);
      return ContextData.fromJson(jsonData);
    } catch (e, stackTrace) {
      _logger.warning('Failed to retrieve context: $key', e, stackTrace);
      return null;
    }
  }

  /// List all context keys
  Future<List<String>> listContextKeys() async {
    _ensureInitialized();

    try {
      final keys = await _atClient!.getAtKeys(regex: 'context.*');
      return keys.map((key) => key.key.replaceFirst('context.', '')).toList();
    } catch (e, stackTrace) {
      _logger.severe('Failed to list context keys', e, stackTrace);
      return [];
    }
  }

  /// Delete context data
  Future<bool> deleteContext(String key) async {
    _ensureInitialized();

    try {
      final atKey = AtKey()
        ..key = 'context.$key'
        ..namespace = 'personalagent'
        ..sharedWith = atSign;

      await _atClient!.delete(atKey);
      _logger.info('Deleted context: $key');
      return true;
    } catch (e, stackTrace) {
      _logger.warning('Failed to delete context: $key', e, stackTrace);
      return false;
    }
  }

  /// Subscribe to incoming messages from Flutter app
  Future<void> subscribeToMessages(
      Future<void> Function(QueryMessage) onQueryReceived) async {
    _ensureInitialized();

    _logger.info('üîî Setting up notification listener');
    _logger.info('   AtClient: ${_atClient != null ? "initialized" : "NULL"}');
    _logger.info(
        '   NotificationService: ${_atClient?.notificationService != null ? "available" : "NULL"}');

    try {
      // Subscribe with same pattern as at_talk - this makes auto-decryption work!
      _logger.info('üì° Subscribing with regex: query.personalagent@');
      _logger.info('   (Following at_talk_gui pattern for auto-decryption)');

      final stream = _atClient!.notificationService
          .subscribe(regex: 'query.personalagent@', shouldDecrypt: true);

      _logger.info('‚úÖ Subscribe call completed, got stream');

      stream.listen(
        (notification) async {
          try {
            _logger.info('üéâ NOTIFICATION RECEIVED!');
            _logger.info('   From: ${notification.from}');
            _logger.info('   Key: ${notification.key}');
            _logger.info('   ID: ${notification.id}');

            // Skip stats notifications (ID: -1)
            if (notification.id == '-1') {
              _logger.info('   ‚è≠Ô∏è  Skipping stats notification');
              return;
            }

            // Filter for query notifications only
            if (!notification.key.contains('query')) {
              _logger.info('   ‚è≠Ô∏è  Skipping non-query notification');
              return;
            }

            // Value should be auto-decrypted by SDK (like at_talk)
            if (notification.value == null) {
              _logger.warning('‚ö†Ô∏è Notification value is null');
              return;
            }

            _logger.info(
                '   Value preview: ${notification.value!.substring(0, notification.value!.length > 100 ? 100 : notification.value!.length)}...');

            // Parse the JSON data - should be decrypted automatically
            final jsonData = json.decode(notification.value!);
            _logger.info('‚úÖ JSON decoded successfully (auto-decrypted!)');

            // Parse as QueryMessage
            final useOllamaOnly = jsonData['useOllamaOnly'] ?? false;
            final conversationHistory =
                jsonData['conversationHistory'] as List<dynamic>?;

            final query = QueryMessage(
              id: jsonData['id'] ??
                  DateTime.now().millisecondsSinceEpoch.toString(),
              content: jsonData['content'] ?? '',
              userId: jsonData['userId'] ?? notification.from ?? '',
              useOllamaOnly: useOllamaOnly,
              conversationHistory:
                  conversationHistory?.cast<Map<String, dynamic>>(),
              timestamp: DateTime.parse(
                jsonData['timestamp'] ?? DateTime.now().toIso8601String(),
              ),
            );

            _logger.info('‚ö° Processing query: ${query.id}');
            _logger.info(
                '   Ollama-Only Mode: ${useOllamaOnly ? "ENABLED üîí" : "disabled"}');
            _logger.info(
                '   Conversation History: ${conversationHistory?.length ?? 0} messages');
            _logger.info(
                '   Content: ${query.content.substring(0, query.content.length > 50 ? 50 : query.content.length)}...');

            // Call the callback to process the query
            await onQueryReceived(query);

            _logger.info('‚úÖ Query processed successfully');
          } catch (e, stackTrace) {
            _logger.severe('‚ùå Failed to parse or process query', e, stackTrace);
          }
        },
        onError: (error, stackTrace) {
          _logger.warning('‚ö†Ô∏è Notification stream error: $error');
          _logger.warning('Stack trace: $stackTrace');
          // The SDK will automatically retry the connection
        },
        onDone: () {
          _logger.info('üîå Notification stream closed');
          _logger.info('   The SDK will automatically reconnect');
        },
        cancelOnError: false, // Keep listening even if there are errors
      );

      _logger.info('‚úÖ‚úÖ‚úÖ Notification listener is ACTIVE and waiting');
      _logger.info('   Pattern: query.*');
      _logger.info('   Namespace: personalagent');
      _logger.info('   Decryption: enabled');
      _logger.info('   Ready to receive from any @sign');
    } catch (e, stackTrace) {
      _logger.severe('Failed to start notification listener', e, stackTrace);
      rethrow;
    }
  }

  /// Send response message to Flutter app
  Future<void> sendResponse(
      String recipientAtSign, ResponseMessage response) async {
    _ensureInitialized();

    try {
      final atKey = AtKey()
        ..key = 'message.${response.id}'
        ..namespace = 'personalagent'
        ..sharedWith = recipientAtSign;

      final jsonData = json.encode(response.toJson());

      // Use notificationService.notify instead of direct notify
      final notificationResult = await _atClient!.notificationService.notify(
        NotificationParams.forUpdate(atKey, value: jsonData),
      );

      _logger.info(
          'Sent response to $recipientAtSign: ${notificationResult.notificationID}');
    } catch (e, stackTrace) {
      _logger.severe('Failed to send response', e, stackTrace);
      rethrow;
    }
  }

  void _ensureInitialized() {
    if (!_isInitialized) {
      throw Exception(
          'AtPlatformService not initialized. Call initialize() first.');
    }
  }

  /// Try to acquire a mutex for a specific identifier (query ID, session ID, etc.).
  /// Returns true if this instance acquired the mutex, false if another instance already has it.
  ///
  /// This implements a simplified mutex pattern for load balancing between multiple agents:
  /// - Uses a combination of get+put to create a mutex
  /// - First agent to successfully create the key wins
  /// - Mutex expires after ttlSeconds to prevent stale locks
  Future<bool> tryAcquireMutex({
    required String mutexId,
    int ttlSeconds = 30,
  }) async {
    _ensureInitialized();

    try {
      // Create mutex key: {mutexId}.query_mutexes.personalagent@{atSign}
      final mutexKey = AtKey()
        ..key = '$mutexId.query_mutexes'
        ..namespace = 'personalagent'
        ..sharedWith = atSign; // Share with self

      // Use a simpler approach: just try to put, then verify
      // Don't check beforehand - this avoids the race condition
      // where both agents see "not found" and both try to acquire
      _logger.info('ÔøΩ Attempting to acquire mutex: $mutexId');

      // Try to create the mutex key with REMOTE server write
      // This is CRITICAL - must use useRemoteAtServer = true
      // Otherwise each agent only updates their local cache!
      final putOptions = PutRequestOptions()
        ..useRemoteAtServer = true; // Force write to remote secondary server
      
      // Generate a unique identifier for THIS agent instance
      final myLockId = '${atSign}_${DateTime.now().microsecondsSinceEpoch}_${instanceId ?? "default"}';
      
      final lockData = json.encode({
        'timestamp': DateTime.now().toIso8601String(),
        'agent': atSign,
        'lockId': myLockId,
      });

      // Write to REMOTE server (not just local cache)
      await _atClient!.put(mutexKey, lockData, putRequestOptions: putOptions);
      _logger.info('üì§ Put mutex to remote server: $myLockId');

      // CRITICAL: Verify we actually won the race
      // Sleep longer to let any concurrent puts settle on the server
      // The last write wins on the atServer
      await Future.delayed(Duration(milliseconds: 200));
      
      // Read back from server to see who won (this will hit the server)
      try {
        final verifyResult = await _atClient!.get(mutexKey);
        if (verifyResult.value != null) {
          final storedData = json.decode(verifyResult.value) as Map<String, dynamic>;
          final storedLockId = storedData['lockId'] as String?;
          
          _logger.info('üì• Read back mutex from server: $storedLockId');
          
          if (storedLockId == myLockId) {
            // We won!
            _logger.info('‚úÖ Acquired mutex: $mutexId (verified: $myLockId)');
            return true;
          } else {
            // Someone else won the race (their write came after ours)
            _logger.info('üîí Lost mutex race to another agent: $mutexId (their lock: $storedLockId)');
            return false;
          }
        }
      } catch (e) {
        _logger.warning('‚ö†Ô∏è Error verifying mutex (will assume acquired): $e');
        return true; // Proceed if we can't verify
      }

      // Shouldn't reach here, but if we do, assume we got it
      _logger.info('‚úÖ Acquired mutex: $mutexId (no stored value to verify)');
      return true;
    } catch (e) {
      // For any error, log it but allow the query to proceed
      // This ensures the system keeps working even if there are unexpected issues
      _logger.warning('‚ö†Ô∏è Error with mutex (will proceed anyway): $e');
      return true;
    }
  }

  /// Cleanup resources
  Future<void> dispose() async {
    // Cleanup if needed
    _isInitialized = false;
  }
}
